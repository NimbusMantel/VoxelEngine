#version 460 core

#extension GL_KHR_vulkan_glsl : enable

#extension GL_ARB_separate_shader_objects : require

#define VoxelDepth 23
#define VoxelToUnit 4096.9f

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, r32ui) uniform restrict readonly uimage3D structure;
layout(binding = 1, rgba32ui) uniform restrict readonly uimage3D material;

layout(binding = 2) buffer restrict RayQueue {
    uint pixel;
} queue;

layout(binding = 3) buffer restrict VisibiliyMask {
    uint[] mask;
} visibility;

layout(binding = 4) buffer restrict HDRImage {
    uint[] data;
} hdrImage;

layout(push_constant) uniform Constants {
    float[9] mat; // offset: 0, alignment: 16
    float    n_x; // offset: 36, alignment: 4
    float    n_y; // offset: 40, alignment: 4
    float    n_z; // offset: 44, alignment: 4
    uvec2    siz; // oofset: 48, alignment: 8
    float    fov; // offset: 56, alignment: 4
} cst;

struct VoxelStack {
    uint  idx; // offset: 0, alignment: 4
    float tax; // offset: 4, alignment: 4
    uint  das; // offset: 8, alignment: 4
    float tin; // offset: 12, alignment: 4
    vec3  pos; // offset: 16, alignment: 16
    uint  vox; // offset: 28, alignment: 4
};

struct RayInit {
    vec3  pos; // offset: 0, alignment: 16
    float dis; // offset: 12, alignment: 4
    vec3  dir; // offset: 16, alignment: 16
    uint  dst; // offset: 28, alignment: 4
    vec3  fac; // offset: 32, alignment: 16
};

void main() {
    const float epsilon = uintBitsToFloat((127 - VoxelDepth) << 23);
    const uint endian = 0x18;

    const uvec2 size = cst.siz;

    const uint pixels = size.x * size.y;

    const vec4 camFrame = vec4(cst.fov, cst.fov * (size.y / float(size.x)), cst.fov * 2.0f / float(size.x - 1), cst.fov * (size.y / float(size.x)) * 2.0f / float(size.y - 1));

    const mat3 camView = mat3(cst.mat[0], cst.mat[1], cst.mat[2], cst.mat[3], cst.mat[4], cst.mat[5], cst.mat[6], cst.mat[7], cst.mat[8]);
    const vec3 camPos = vec3(cst.n_x, cst.n_y, cst.n_z);

    VoxelStack stack[VoxelDepth];
    RayInit ray;

    uint pixIdx;

    queue.pixel = 0;
    barrier();
    
    while (true) {
        if (false) { // ray queue is non-empty
            // get ray from queue
        }
        else {
            pixIdx = atomicAdd(queue.pixel, 1);

            if (pixIdx >= pixels) {
                break;
            }

            ray = RayInit(camPos, 0.0f, camView * normalize(vec3((pixIdx % size.x) * camFrame.z - camFrame.x, (size.y - (pixIdx / size.x) - 1) * camFrame.w - camFrame.y, -1.0f)),
                pixIdx << 1, vec3(1.0f));

            pixIdx <<= 1;

            atomicExchange(hdrImage.data[pixIdx], 0x00);
            atomicExchange(hdrImage.data[pixIdx | 0x01], 0x00);
        }

        vec3 pixel = vec3(0.0f, 0.0f, 0.0f);

        {
            vec3 norPos = ray.pos;

            uint octant_mask = 0x00;

		    if (ray.dir.x > 0.0f) { octant_mask |= 1; norPos.x = 3.0f - norPos.x; }
		    if (ray.dir.y > 0.0f) { octant_mask |= 2; norPos.y = 3.0f - norPos.y; }
            if (ray.dir.z > 0.0f) { octant_mask |= 4; norPos.z = 3.0f - norPos.z; }

            vec3 t_coef = vec3(1.0f) / -max(abs(ray.dir), vec3(epsilon));
		    vec3 t_bias = norPos * t_coef;

		    float t_min = max(max(2.0f * t_coef.x - t_bias.x, 2.0f * t_coef.y - t_bias.y), 2.0f * t_coef.z - t_bias.z);
		    float t_max = min(min(t_coef.x - t_bias.x, t_coef.y - t_bias.y), t_coef.z - t_bias.z);
		
		    float h = t_max;

		    t_min = max(t_min, 0.0f);
            t_max = min(t_max, 1.0f);

            uvec4 parent = uvec4(0, 0, 0, 0);
            uint voxel = 0x00;

            uint idx = 0x00;

            vec3 pos = vec3(1.0f, 1.0f, 1.0f);

            uint scale = VoxelDepth - 1;
            float scaExp2 = 0.5f;

            if ((norPos.x - 1.5f) > t_min) { idx |= 1; pos.x = 1.5f; }
		    if ((norPos.y - 1.5f) > t_min) { idx |= 2; pos.y = 1.5f; }
            if ((norPos.z - 1.5f) > t_min) { idx |= 4; pos.z = 1.5f; }

            uint step_mask = 0x00;

            while (scale < VoxelDepth) {
                if (voxel == 0x00) {
                    voxel = imageLoad(structure, ivec3(parent.xyz)).x;
                }

                vec3 t_corner = pos * t_coef - t_bias;

                float tc_max = min(min(t_corner.x, t_corner.y), t_corner.z);

                uint cidx = idx ^ octant_mask;

                bool shouldRender = ((voxel & 0xFF) == 0x00) || ((voxel & 0x80000000) != 0x00);

                if (!shouldRender && ((voxel & (0x80U >> cidx)) != 0x00) && (t_min <= t_max)) {
                    atomicOr(visibility.mask[parent.w >> 5], 0x80000000U >> ((parent.w & 0x0000001F) ^ endian));
                    
                    if (tc_max < h) {
                        stack[scale].idx = parent.w;
                        stack[scale].tax = t_max;
                    }

                    stack[scale].das = (floatBitsToUint((tc_max - t_min) / scaExp2) & 0xFFFFFFF8) | (step_mask & 0x07);
                    stack[scale].tin = t_min;
                    stack[scale].pos = pos;
                    stack[scale].vox = voxel;

                    h = tc_max;

                    parent.w = (voxel >> 8) & 0x001FFFFF;

                    parent.x = ((parent.w << 1) & 0xFE) | (cidx & 0x01);
                    parent.y = ((parent.w >> 6) & 0xFE) | ((cidx >> 1) & 0x01);
                    parent.z = ((parent.w >> 13) & 0xFE) | ((cidx >> 2) & 0x01);
                    parent.w = (parent.w << 3) | cidx;

                    idx = 0x00;

                    scale--;
                    scaExp2 *= 0.5f;

                    if ((scaExp2 * t_coef.x + t_corner.x) > t_min) { idx |= 1; pos.x += scaExp2; }
                    if ((scaExp2 * t_coef.y + t_corner.y) > t_min) { idx |= 2; pos.y += scaExp2; }
                    if ((scaExp2 * t_coef.z + t_corner.z) > t_min) { idx |= 4; pos.z += scaExp2; }

                    t_max = min(t_max, tc_max);
                    
                    voxel = 0x00;

                    continue;
                }

                step_mask = 0x00;

                if (t_corner.x <= tc_max) { step_mask |= 1; pos.x -= scaExp2; }
			    if (t_corner.y <= tc_max) { step_mask |= 2; pos.y -= scaExp2; }
			    if (t_corner.z <= tc_max) { step_mask |= 4; pos.z -= scaExp2; }

			    idx ^= step_mask;
                t_min = tc_max;

                if ((idx & step_mask) != 0x00) {
                    if (shouldRender) {
                        atomicOr(visibility.mask[parent.w >> 5], 0x80000000U >> ((parent.w & 0x0000001F) ^ endian));

                        uint curr_side = (stack[scale + 1].das & 0x06) + uint(bool((octant_mask ^ 0x07) & stack[scale + 1].das));

                        float curr_dist = (stack[scale + 1].tin + ray.dis) * VoxelToUnit;
                        float curr_fallOff = 1.0f + curr_dist * curr_dist;

                        float curr_depth = uintBitsToFloat(stack[scale + 1].das & 0xFFFFFFF8);

                        pixel = vec3(0.0f, curr_depth * 0.5, 0.0f);

                        break;
                    }

                    uint difBits = 0x00;

                    if ((step_mask & 0x01) != 0x00) difBits |= floatBitsToUint(pos.x) ^ floatBitsToUint(pos.x + scaExp2);
                    if ((step_mask & 0x02) != 0x00) difBits |= floatBitsToUint(pos.y) ^ floatBitsToUint(pos.y + scaExp2);
                    if ((step_mask & 0x04) != 0x00) difBits |= floatBitsToUint(pos.z) ^ floatBitsToUint(pos.z + scaExp2);

                    scale = (floatBitsToUint(float(difBits)) >> 23) - 127;
                    scaExp2 = uintBitsToFloat((127 - (VoxelDepth - scale)) << 23);

                    uvec3 sh = floatBitsToUint(pos) >> scale;

                    pos = uintBitsToFloat(sh << scale);

                    idx = (sh.x & 0x01) | ((sh.y & 0x01) << 1) | ((sh.z & 0x01) << 2);

                    t_max = stack[scale].tax;
                    voxel = stack[scale].vox;

                    h = 0.0f;
                }
            }
        }

        vec4 result = vec4(pixel, 1.0f);

        uint expected, latest = 0x00;

        do {
            expected = latest;

            latest = atomicCompSwap(hdrImage.data[ray.dst], expected, packHalf2x16(result.xy + unpackHalf2x16(expected)));
        } while (latest != expected);

        latest = 0x00;

        do {
            expected = latest;

            latest = atomicCompSwap(hdrImage.data[ray.dst | 0x01], expected, packHalf2x16(result.zw + unpackHalf2x16(expected)));
        } while (latest != expected);
    }
}