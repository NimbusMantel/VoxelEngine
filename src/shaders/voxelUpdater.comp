#version 460 core

#extension GL_KHR_vulkan_glsl : enable

#extension GL_ARB_separate_shader_objects : require

#extension GL_AMD_gpu_shader_int16 : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_vote : require

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, r8ui) uniform restrict readonly uimageBuffer update; // used to get byte addressable buffer storage

layout(binding = 1, r32ui) uniform restrict uimage3D structure;
layout(binding = 2, rgba32ui) uniform restrict uimage3D material;

layout(binding = 3) buffer restrict UpdateQueue {
    uint offset;
} queue;

#define packOperationData(s, o) uint((s << 3) | (o & 0x03))
#define unpackGroupSize(v) uint(v + 1)
#define unpackSingleSize(v) uint(v >> 3)

const uint operationData[16] = uint[16](
	packOperationData(0, 0),              // BUF_END
	packOperationData(1, 3),              // STR_CLD_M
	packOperationData(3, 3),              // VOX_CPY_M
	packOperationData(3 + 3, 0),          // VOX_CPY_S
	packOperationData(3 + 1, 3),          // STR_LOA_M
	packOperationData(3 + 1, 0),          // STR_CLD_S
	packOperationData(3 + 3, 0),          // STR_PNT_S
	packOperationData(3 + (3 + 1), 0),    // STR_LOA_S
	packOperationData(8 + 4 + 4, 3),      // MAT_LOA_M
	packOperationData(3 + 4, 0),          // MAT_xxL_S
	packOperationData(3 + 4, 0),          // MAT_xSx_S
	packOperationData(3 + (4 + 4), 0),    // MAT_xSL_S
	packOperationData(3 + 8, 0),          // MAT_Cxx_S
	packOperationData(3 + (8 + 4), 0),    // MAT_CxL_S
	packOperationData(3 + (8 + 4), 0),    // MAT_CSx_S
	packOperationData(3 + (8 + 4 + 4), 0) // MAT_LOA_S
);

#define updateLOAD(i) imageLoad(update, int(i)).x

#define unserialiseUint8(i) updateLOAD(i)
#define unserialiseUint24(i) ((updateLOAD(i) << 16) | (updateLOAD(i + 1) << 8) | updateLOAD(i + 2))
#define unserialiseUint32(i) ((updateLOAD(i) << 24) | (updateLOAD(i + 1) << 16) | (updateLOAD(i + 2) << 8) | updateLOAD(i + 3))

#define unpackAddress(a) ((ivec3(a >> 2, a >> 8, a >> 15) & 0xFE) + (ivec3(a, a >> 1, a >> 2) & 0x01))

void main() {
	queue.offset = 0;
    barrier();
	
	while (true) {
		uint begin = 0;

		if (subgroupElect()) {
			uint expect;

			do {
				expect = begin;
				begin = unserialiseUint8(expect);
				begin = atomicCompSwap(queue.offset, expect, unpackGroupSize(operationData[begin]) * (gl_SubgroupSize >> 3) + expect + 1);
			} while (begin != expect);
		}

		begin = subgroupBroadcastFirst(begin);

		const uint opcode = unserialiseUint8(begin);
		
		if (subgroupAll(opcode == 0x0)) {
			break;
		}
		
		begin += 1 + unpackGroupSize(operationData[opcode]) * (gl_SubgroupInvocationID >> 3);
		
		const uint mask = unserialiseUint8(begin);
		
		if ((mask & (0x80U >> (gl_SubgroupInvocationID & 0x07))) != 0x00) {
			if (subgroupAll(opcode == 0x1)) { // STR_CLD_M
				const uint address = unserialiseUint24(begin) | (gl_SubgroupInvocationID & 0x07);

				begin += unpackSingleSize(operationData[0x1]) * (gl_SubgroupInvocationID & 0x07) + 1;

				imageStore(structure, unpackAddress(address), uvec4((imageLoad(structure, unpackAddress(address)).x & 0xFFFFFF00) | unserialiseUint8(begin)));
			}
			else if (subgroupAll(opcode == 0x2)) { // VOX_CPY_M
				const uint from = unserialiseUint24(begin) | (gl_SubgroupInvocationID & 0x07);

				begin += unpackSingleSize(operationData[0x2]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint to = unserialiseUint24(begin);

				imageStore(structure, unpackAddress(to), imageLoad(structure, unpackAddress(from)));
				imageStore(material, unpackAddress(to), imageLoad(material, unpackAddress(from)));
			}
			else if (subgroupAll(opcode == 0x3)) { // VOX_CPY_S
				begin += unpackSingleSize(operationData[0x3]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint from = unserialiseUint24(begin);

				begin += 3;

				const uint to = unserialiseUint24(begin);

				imageStore(structure, unpackAddress(to), imageLoad(structure, unpackAddress(from)));
				imageStore(material, unpackAddress(to), imageLoad(material, unpackAddress(from)));
			}
			else if (subgroupAll(opcode == 0x4)) { // STR_LOA_M
				const uint address = unserialiseUint24(begin) | (gl_SubgroupInvocationID & 0x07);

				begin += unpackSingleSize(operationData[0x4]) * (gl_SubgroupInvocationID & 0x07) + 1;

				imageStore(structure, unpackAddress(address), uvec4(unserialiseUint32(begin)));
			}
			else if (subgroupAll(opcode == 0x5)) { // STR_CLD_S
				begin += unpackSingleSize(operationData[0x5]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				imageStore(structure, unpackAddress(address), uvec4((imageLoad(structure, unpackAddress(address)).x & 0xFFFFFF00) | unserialiseUint8(begin)));
			}
			else if (subgroupAll(opcode == 0x6)) { // STR_PNT_S
				begin += unpackSingleSize(operationData[0x6]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				imageStore(structure, unpackAddress(address), uvec4((unserialiseUint24(begin) << 8) | (imageLoad(structure, unpackAddress(address)).x & 0x000000FF)));
			}
			else if (subgroupAll(opcode == 0x7)) { // STR_LOA_S
				begin += unpackSingleSize(operationData[0x7]) * (gl_SubgroupInvocationID & 0x07) + 1;
				
				const uint address = unserialiseUint24(begin);
				
				begin += 3;
				
				imageStore(structure, unpackAddress(address), uvec4(unserialiseUint32(begin)));
			}
			else if (subgroupAll(opcode == 0x8)) { // MAT_LOA_M
				const uint address = unserialiseUint24(begin) | (gl_SubgroupInvocationID & 0x07);

				begin += unpackSingleSize(operationData[0x8]) * (gl_SubgroupInvocationID & 0x07) + 1;

				imageStore(material, unpackAddress(address), uvec4(unserialiseUint32(begin), unserialiseUint32(begin + 4), unserialiseUint32(begin + 8), unserialiseUint32(begin + 12)));
			}
			else if (subgroupAll(opcode == 0x9)) { // MAT_xxL_S
				begin += unpackSingleSize(operationData[0x9]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				const uvec4 oldMaterial = imageLoad(material, unpackAddress(address));

				imageStore(material, unpackAddress(address), uvec4(oldMaterial.xyz, unserialiseUint32(begin)));
			}
			else if (subgroupAll(opcode == 0xA)) { // MAT_xSx_S
				begin += unpackSingleSize(operationData[0xA]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				const uvec4 oldMaterial = imageLoad(material, unpackAddress(address));

				imageStore(material, unpackAddress(address), uvec4(oldMaterial.xy, unserialiseUint32(begin), oldMaterial.z));
			}
			else if (subgroupAll(opcode == 0xB)) { // MAT_xSL_S
				begin += unpackSingleSize(operationData[0xB]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				const uvec4 oldMaterial = imageLoad(material, unpackAddress(address));

				imageStore(material, unpackAddress(address), uvec4(oldMaterial.xy, unserialiseUint32(begin), unserialiseUint32(begin + 4)));
			}
			else if (subgroupAll(opcode == 0xC)) { // MAT_Cxx_S
				begin += unpackSingleSize(operationData[0xC]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				const uvec4 oldMaterial = imageLoad(material, unpackAddress(address));

				imageStore(material, unpackAddress(address), uvec4(unserialiseUint32(begin), unserialiseUint32(begin + 4), oldMaterial.zw));
			}
			else if (subgroupAll(opcode == 0xD)) { // MAT_CxL_S
				begin += unpackSingleSize(operationData[0xD]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				const uvec4 oldMaterial = imageLoad(material, unpackAddress(address));

				imageStore(material, unpackAddress(address), uvec4(unserialiseUint32(begin), unserialiseUint32(begin + 4), oldMaterial.z, unserialiseUint32(begin + 8)));
			}
			else if (subgroupAll(opcode == 0xE)) { // MAT_CSx_S
				begin += unpackSingleSize(operationData[0xE]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				const uvec4 oldMaterial = imageLoad(material, unpackAddress(address));

				imageStore(material, unpackAddress(address), uvec4(unserialiseUint32(begin), unserialiseUint32(begin + 4), unserialiseUint32(begin + 8), oldMaterial.w));
			}
			else if (subgroupAll(opcode == 0xF)) { // MAT_LOA_S
				begin += unpackSingleSize(operationData[0xF]) * (gl_SubgroupInvocationID & 0x07) + 1;

				const uint address = unserialiseUint24(begin);

				imageStore(material, unpackAddress(address), uvec4(unserialiseUint32(begin), unserialiseUint32(begin + 4), unserialiseUint32(begin + 8), unserialiseUint32(begin + 12)));
			}
		}
	}
}