#version 460 core

#extension GL_KHR_vulkan_glsl : enable

#extension GL_ARB_separate_shader_objects : require

#extension GL_AMD_gpu_shader_int16 : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_vote : require

layout(local_size_x = 32) in;

layout(binding = 0) buffer restrict readonly UpdateData {
    uint16_t[] data;
} update;

layout(binding = 1, r32ui) uniform restrict writeonly uimage3D structure;
layout(binding = 2, rgba32ui) uniform restrict writeonly uimage3D material;

layout(binding = 3) buffer restrict UpdateQueue {
    uint offset;
} queue;

#define packShort2x16(a, b) uint((a << 16) | (b & 0xFFFF))
#define unpackGroupSize(v) uint(1 + (v >> 16) * (8 / (v & 0xFFFF)))

#define unpackByte2x8(a, i) ((a[i >> 1] >> ((i & 0x01) << 3)) & uint16_t(0xFF))

//#define unpackByte4x8(v) (uvec4(v, v >> 8, v >> 16, v >> 24) & 0xFF)

const uint operationData[16] = uint[16](
	packShort2x16(0, 1),                   // BUF_END
	packShort2x16(3 + 8 * 1, 8),           // STR_CLD_M
	packShort2x16(3 + 8 * 3, 8),           // VOX_CPY_M
	packShort2x16(3 + 3, 1),               // VOX_CPY_S
	packShort2x16(3 + 8 * (3 + 1), 8),     // STR_LOA_M
	packShort2x16(3 + 1, 1),               // STR_CLD_S
	packShort2x16(3 + 3, 1),               // STR_PNT_S
	packShort2x16(3 + (3 + 1), 1),         // STR_LOA_S
	packShort2x16(3 + 8 * (8 + 4 + 4), 8), // MAT_LOA_M
	packShort2x16(3 + 4, 1),               // MAT_xxL_S
	packShort2x16(3 + 4, 1),               // MAT_xSx_S
	packShort2x16(3 + (4 + 4), 1),         // MAT_xSL_S
	packShort2x16(3 + 8, 1),               // MAT_Cxx_S
	packShort2x16(3 + (8 + 4), 1),         // MAT_CxL_S
	packShort2x16(3 + (8 + 4), 1),         // MAT_CSx_S
	packShort2x16(3 + (8 + 4 + 4), 1)      // MAT_LOA_S
);

#define VOX_STRUCTURE(children, mask) uint((uint(!bool(children)) << 31) | ((children & 0x001FFFFF) << 8) | (mask & 0xFF))
#define VOX_EMPTY 0x00

const uint testData[136] = uint[136](
    VOX_STRUCTURE(1, 0x01), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_STRUCTURE(2, 0x80),
	VOX_STRUCTURE(3, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(4, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(5, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(6, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(7, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(8, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(9, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(10, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(11, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(12, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(13, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(14, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(15, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(16, 0x80), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY,
	VOX_STRUCTURE(0x0, 0x0), VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY, VOX_EMPTY
);

void main() {
	queue.offset = 0;
    barrier();
	
	while (true) {
		uint begin = 0;

		if (subgroupElect()) {
			uint expect;

			do {
				expect = begin;
				begin = unpackByte2x8(update.data, expect);
				begin = atomicCompSwap(queue.offset, expect, expect + unpackGroupSize(operationData[begin]) * (gl_SubgroupSize >> 3));
			} while (begin != expect);
		}

		begin = subgroupBroadcastFirst(begin);

		const uint opcode = unpackByte2x8(update.data, begin);
		
		if (subgroupAll(opcode == 0x0)) {
			break;
		}
		
		begin += 1 + ((operationData[opcode] >> 13) + 1) * (gl_SubgroupID >> 3);

		const uint mask = unpackByte2x8(update.data, begin);
		
		// TO DO: Execute operations
		break;
	}

	// Cleanup if necessary

	ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);

    for (uint x = gl_GlobalInvocationID.x; x < 17; x += gl_WorkGroupSize.x) {
        uint idx = x << 3;

        ivec3 pos = ivec3(x << 1, x >> 6, x >> 13) & 0xFE;

        imageStore(structure, pos + ivec3(0, 0, 0), uvec4(testData[idx + 0], 0, 0, 0));
        imageStore(structure, pos + ivec3(1, 0, 0), uvec4(testData[idx + 1], 0, 0, 0));
        imageStore(structure, pos + ivec3(0, 1, 0), uvec4(testData[idx + 2], 0, 0, 0));
        imageStore(structure, pos + ivec3(1, 1, 0), uvec4(testData[idx + 3], 0, 0, 0));
        imageStore(structure, pos + ivec3(0, 0, 1), uvec4(testData[idx + 4], 0, 0, 0));
        imageStore(structure, pos + ivec3(1, 0, 1), uvec4(testData[idx + 5], 0, 0, 0));
        imageStore(structure, pos + ivec3(0, 1, 1), uvec4(testData[idx + 6], 0, 0, 0));
        imageStore(structure, pos + ivec3(1, 1, 1), uvec4(testData[idx + 7], 0, 0, 0));
    }
}