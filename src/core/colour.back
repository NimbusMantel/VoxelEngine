uint32_t colourMix(uint32_t colA, uint32_t colB) {
	float alpA = (colA & 0x000000FF) / 255.0f;
	float alpB = (colB & 0x000000FF) / 255.0f;

	col dA = rgbTOlab(col((colA & 0xFF000000) >> 24, (colA & 0x00FF0000) >> 16, (colA & 0x0000FF00) >> 8));
	col dB = rgbTOlab(col((colB & 0xFF000000) >> 24, (colB & 0x00FF0000) >> 16, (colB & 0x0000FF00) >> 8));

	DEBUG_LOG_RAW("Colour", "dA(%f|%f|%f)", dA.x, dA.y, dA.z);
	DEBUG_LOG_RAW("Colour", "dB(%f|%f|%f)", dB.x, dB.y, dB.z);

	col lchA = labTOlch(rgbTOlab(col((colA & 0xFF000000) >> 24, (colA & 0x00FF0000) >> 16, (colA & 0x0000FF00) >> 8)));
	col lchB = labTOlch(rgbTOlab(col((colB & 0xFF000000) >> 24, (colB & 0x00FF0000) >> 16, (colB & 0x0000FF00) >> 8)));

	DEBUG_LOG_RAW("Colour", "A(%f|%f|%f)", lchA.x, lchA.y, lchA.z);
	DEBUG_LOG_RAW("Colour", "B(%f|%f|%f)", lchB.x, lchB.y, lchB.z);

	if (alpA == 0.0f && alpB > 0.0f) return colB;
	if (alpB == 0.0f && alpA > 0.0f) return colA;
	if (alpA == 0.0f && alpB == 0.0f) return 0x0;

	float l = lchA.x + (lchB.x - lchA.x) * alpB / (alpA + alpB);
	float c = lchA.y + (lchB.y - lchA.y) * alpB / (alpA + alpB);

	if ((lchA.z - lchB.z) > 180.0f) lchB.z += 360.0f;
	else if ((lchA.z - lchB.z) < -180.0f) lchA.z += 360.0f;

	float h = lchA.z + (lchB.z - lchA.z) * alpB / (alpA + alpB);

	h = fmodf(h, 360.0f);

	DEBUG_LOG_RAW("Colour", "C(%f|%f|%f)", l, c, h);

	col dC = lchTOlab(col(l, c, h));

	DEBUG_LOG_RAW("Colour", "dC(%f|%f|%f)", dC.x, dC.y, dC.z);

	col rgb = labTOrgb(lchTOlab(col(l, c, h)));

	return (((uint32_t)roundf(rgb.x) << 24) | ((uint32_t)roundf(rgb.y) << 16) | ((uint32_t)roundf(rgb.z) << 8) | (uint32_t)roundf((1.0f - (1.0f - alpA) * (1.0f - alpB)) * 255.0f));
}

col rgbTOlab(col rgb) {
	float r = rgb.x / 255.0f;
	float g = rgb.y / 255.0f;
	float b = rgb.z / 255.0f;

	r = (r > 0.04045f) ? powf((r + 0.055f) / 1.055f, 2.4f) : r / 12.92f;
	g = (g > 0.04045f) ? powf((g + 0.055f) / 1.055f, 2.4f) : g / 12.92f;
	b = (b > 0.04045f) ? powf((b + 0.055f) / 1.055f, 2.4f) : b / 12.92f;

	float x = (r * 0.4124f + g * 0.3576f + b * 0.1805f) / 0.95047f;
	float y = (r * 0.2126f + g * 0.7152f + b * 0.0722f) / 1.00000f;
	float z = (r * 0.0193f + g * 0.1192f + b * 0.9505f) / 1.08883f;

	x = (x > 0.008856f) ? powf(x, 1.0f / 3.0f) : (7.787f * x) + 16.0f / 116.0f;
	y = (y > 0.008856f) ? powf(y, 1.0f / 3.0f) : (7.787f * y) + 16.0f / 116.0f;
	z = (z > 0.008856f) ? powf(z, 1.0f / 3.0f) : (7.787f * z) + 16.0f / 116.0f;

	return col((116.0f * y) - 16.0f, 500.0f * (x - y), 200.0f * (y - z));
}

col labTOrgb(col lab) {
	float y = (lab.x + 16.0f) / 116.0f;
	float x = lab.y / 500.0f + y;
	float z = y - lab.z / 200.0f;

	x = 0.95047 * ((x * x * x > 0.008856) ? x * x * x : (x - 16 / 116) / 7.787);
	y = 1.00000 * ((y * y * y > 0.008856) ? y * y * y : (y - 16 / 116) / 7.787);
	z = 1.08883 * ((z * z * z > 0.008856) ? z * z * z : (z - 16 / 116) / 7.787);

	float r = x *  3.2406f + y * -1.5372f + z * -0.4986f;
	float g = x * -0.9689f + y *  1.8758f + z *  0.0415f;
	float b = x *  0.0557f + y * -0.2040f + z *  1.0570f;

	r = (r > 0.0031308f) ? (1.055f * powf(r, 1.0f / 2.4f) - 0.055f) : 12.92f * r;
	g = (g > 0.0031308f) ? (1.055f * powf(g, 1.0f / 2.4f) - 0.055f) : 12.92f * g;
	b = (b > 0.0031308f) ? (1.055f * powf(b, 1.0f / 2.4f) - 0.055f) : 12.92f * b;

	return col(MAX(0.0f, MIN(1.0f, r)) * 255.0f, MAX(0.0f, MIN(1.0f, g)) * 255.0f, MAX(0.0f, MIN(1.0f, b)) * 255.0f);
}

col labTOlch(col lab) {
	return col(lab.x, sqrtf(lab.y * lab.y + lab.z * lab.z) * 100.0f / 128.0, fmodf(atan2f(lab.z, lab.y) * 180.0f / M_PI + 360.0f, 360.0f));
}

col lchTOlab(col lch) {
	return col(lch.x, cosf(lch.z * M_PI / 180.0f) * lch.y * 128.0f / 100.0f, sinf(lch.z * M_PI / 180.0f) * lch.y * 128.0f / 100.0f);
}*/

/*uint32_t colourMix(uint32_t colA, uint32_t colB) {
	float colA_r = ((colA & 0xFF000000) >> 24) / 255.0f;
	float colA_g = ((colA & 0x00FF0000) >> 16) / 255.0f;
	float colA_b = ((colA & 0x0000FF00) >> 8) / 255.0f;
	float colA_a = (colA & 0x000000FF) / 255.0f;

	float colB_r = ((colB & 0xFF000000) >> 24) / 255.0f;
	float colB_g = ((colB & 0x00FF0000) >> 16) / 255.0f;
	float colB_b = ((colB & 0x0000FF00) >> 8) / 255.0f;
	float colB_a = (colB & 0x000000FF) / 255.0f;

	if ((colA_a + colB_a) == 0.0f) return 0x00000000;

	float colR_r = colA_r + (colB_r - colA_r) * colB_a / (colA_a + colB_a);
	float colR_g = colA_g + (colB_g - colA_g) * colB_a / (colA_a + colB_a);
	float colR_b = colA_b + (colB_b - colA_b) * colB_a / (colA_a + colB_a);
	float colR_a = 1.0f - (1.0f - colA_a) * (1.0f - colB_a);
	
	return (((uint32_t)roundf(colR_r * 255.0f) << 24) | ((uint32_t)roundf(colR_g * 255.0f) << 16) | ((uint32_t)roundf(colR_b * 255.0f) << 8) | (uint32_t)roundf(colR_a * 255.0f));
}

double calcAbsorbance(double value) {
	if (value == 0) value = 0.00001;

	return (pow(1.0 - value, 2.0) / (2.0 * value));
}

double calcReflectance(double value) {
	return (1.0 + value - sqrt(pow(value, 2.0) + 2.0 * value));
}

uint32_t rgbaTOryba(uint32_t rgba) {
	uint8_t iRed = (rgba & 0xFF000000) >> 24;
	uint8_t iGreen = (rgba & 0x00FF0000) >> 16;
	uint8_t iBlue = (rgba & 0x0000FF00) >> 8;
	uint8_t iAlpha = (rgba & 0x000000FF);

	uint8_t iWhite = MAX(iRed, MAX(iGreen, iBlue));

	iRed -= iWhite;
	iGreen -= iWhite;
	iBlue -= iWhite;

	uint8_t iMaxGreen = MAX(iRed, MAX(iGreen, iBlue));

	uint8_t iYellow = MIN(iRed, iGreen);

	iRed -= iYellow;
	iGreen -= iYellow;

	if (iBlue > 0 && iGreen > 0) {
		iBlue /= 2;
		iGreen /= 2;
	}

	iYellow += iGreen;
	iBlue += iGreen;

	uint8_t iMaxYellow = MAX(iRed, MAX(iYellow, iBlue));

	if (iMaxYellow > 0) {
		float iN = iMaxGreen / (float)iMaxYellow;

		iRed *= iN;
		iYellow *= iN;
		iBlue *= iN;
	}

	iRed += iWhite;
	iYellow += iWhite;
	iBlue += iWhite;

	return (((uint32_t)iRed << 24) | ((uint32_t)iYellow << 16) | ((uint32_t)iBlue << 8) | iAlpha);
}

uint32_t rybaTOrgba(uint32_t ryba) {
	uint8_t iRed = (ryba & 0xFF000000) >> 24;
	uint8_t iYellow = (ryba & 0x00FF0000) >> 16;
	uint8_t iBlue = (ryba & 0x0000FF00) >> 8;
	uint8_t iAlpha = (ryba & 0x000000FF);

	uint8_t iWhite = MAX(iRed, MAX(iYellow, iBlue));

	iRed -= iWhite;
	iYellow -= iWhite;
	iBlue -= iWhite;

	uint8_t iMaxYellow = MAX(iRed, MAX(iYellow, iBlue));

	uint8_t iGreen = MIN(iYellow, iBlue);

	iYellow -= iGreen;
	iBlue -= iGreen;

	if (iBlue > 0 && iGreen > 0) {
		iBlue *= 2;
		iGreen *= 2;
	}

	iRed += iYellow;
	iGreen += iYellow;

	uint8_t iMaxGreen = MAX(iRed, MAX(iGreen, iBlue));

	if (iMaxGreen > 0) {
		float iN = iMaxYellow / (float)iMaxGreen;

		iRed *= iN;
		iGreen *= iN;
		iBlue *= iN;
	}

	iRed += iWhite;
	iGreen += iWhite;
	iBlue += iWhite;

	return (((uint32_t)iRed << 24) | ((uint32_t)iGreen << 16) | ((uint32_t)iBlue << 8) | iAlpha);
}