Voxel Buffer Layout:
  Structure:
    1b-break: children unloaded
    2b-unused
    21b-pointer:
      break=0: children pointer
      break=1: extended colour
    8b-children: mask determining children's existence, count from msb
  Material:
    8B-colour:
      10b-beta
      break=0:
        18b-red (compressed)
        18b-green (compressed)
        18b-blue (compressed)
      break=1:
        11b-redParticle
        12b-greenParticle
        11b-blueParticle
        12b-redMaterial
        12b-greenMaterial
        11b-blueMaterial
    4B-surface:
      7b-refraction
      9b-metallic
      6b-specular
      10b-roughness
    4B-light:
      11b-red
      11b-green
      10b-blue

Voxel Buffer Updates:
  General structure:
    4b-opcode, 4b-unused
    N x (1B-mask, data)
    
    N   : number of data sets per group, depends on sub group size (32/8 for NVIDIA, 64/8 for AMD)
    mask: which sub-data sets should be used
  Operations:
    Organisation:
      0000: end [mask: 0x00 | data: null]
    Voxel loading:
      0001: load siblings [data: 3B-address, 8 x (4B-structure, 16B-material)]
    Voxel modification:
      0010: change pointer+colour [data: 8 x (3B-address, 3B-pointer, 8B-colour)]
      0011: copy voxel [data: 8 x (3B-from, 3B-to)]
    Structure loading:
      0100: load siblings [data: 3B-address, 8 x 4B-structure]
      0101: load single [data: 8 x (3B-address, 4B-structure)]
    Structure modification:
      0110: change children [data: 8 x (3B-address, 1B-mask)]
      0111: move children [data: 8 x (3B-address, 3B-pointer)]
    Material loading:
      1000: load siblings [data: 3B-address, 8 x (8B-colour, 4B-surface, 4B-light)]
      1csl: load single [data: 8 x (3B-address, c ? 8B-colour, s ? 4B-surface, l ? 4B-light)]