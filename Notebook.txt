Voxel Buffer Layout:
  Structure:
    1b-break: children unloaded
    2b-unused
    21b-pointer:
      break=0: children pointer
      break=1: extended colour
    8b-children: mask determining children's existence, count from msb
  Material:
    8B-colour:
      10b-beta
      break=0:
        18b-red (compressed)
        18b-green (compressed)
        18b-blue (compressed)
      break=1:
        11b-redParticle
        12b-greenParticle
        11b-blueParticle
        12b-redMaterial
        12b-greenMaterial
        11b-blueMaterial
    4B-surface:
      7b-refraction
      9b-metallic
      6b-specular
      10b-roughness
    4B-light:
      11b-red
      11b-green
      10b-blue

Voxel Buffer Updates:
  General structure:
    4b-opcode, 4b-unused
    N x (1B-mask, data)
    
    N   : number of data sets per group, depends on sub group size (32/8 for NVIDIA, 64/8 for AMD)
    mask: which sub-data sets should be used
  Operations:
    0000: end of buffer [mask: 0x00 | data: null]
	0001: change children (siblings) [data: 3B-address, 8 x 1B-children]
	0010: copy voxel (siblings) [data: 3B-from, 8 x 3B-to]
	0011: copy voxel (single) [data: 3B-from, 3B-to]
	0100: load structure (siblings) [data: 3B-address, 8 x 4B-structure]
	0101: change children (single) [data: 3B-address, 1B-children]
	0110: change pointer (single) [data: 3B-address, 3B-pointer]
	0111: load structure (single) [data: 3B-address, 1B-children]
	1000: load material (siblings) [data: 3B-address, 8 x (8B-colour, 4B-surface, 4B-light)]
	1csl: change material (single) [data: 3B-address, c ? 8B-colour, s ? 4B-surface, l ? 4B-light]
	1111: load material (single) [data: 3B-address, 8B-colour, 4B-surface, 4B-light]