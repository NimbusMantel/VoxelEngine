; SPIR-V
; Version: 1.3
; Generator: Moritz Langenstein
; Bound: 154
; Schema: 0

; Capabilities
               OpCapability Shader
               OpCapability Linkage
               OpCapability GroupNonUniform
               OpCapability GroupNonUniformArithmetic
               OpCapability GroupNonUniformShuffle
               OpCapability GroupNonUniformShuffleRelative
               OpCapability GroupNonUniformClustered

; GLSL 4.5 extended instruction set + logical memory model
       %glsl = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450

; Export function void subgroupOctRayIntersectUnits(const vec3 a, const vec3 d0, out vec3 i0, out vec3 i1)
               OpDecorate %soriu LinkageAttributes "subgroupOctRayIntersectUnits" Export

; ID Decorations

               OpDecorate %sid RelaxedPrecision
               OpDecorate %sid BuiltIn SubgroupLocalInvocationId
               OpDecorate %2 RelaxedPrecision
               OpDecorate %cid RelaxedPrecision
               OpDecorate %d0_inv NoContraction
               OpDecorate %d0_dot_inv NoContraction
               OpDecorate %d0_nrm_dot NoContraction
               OpDecorate %p0 NoContraction
               OpDecorate %p1 NoContraction
               OpDecorate %p2 NoContraction
               OpDecorate %v0 NoContraction
               OpDecorate %v1 NoContraction
               OpDecorate %v2 NoContraction

; Value type declarations
       %void = OpTypeVoid
      %float = OpTypeFloat 32
    %v3float = OpTypeVector %float 3
       %uint = OpTypeInt 32 0
     %v4uint = OpTypeVector %uint 4
       %bool = OpTypeBool
     %v3bool = OpTypeVector %bool 3

; Constant value declarations
     %uint_0 = OpConstant %uint 0
     %uint_1 = OpConstant %uint 1
     %uint_2 = OpConstant %uint 2
     %uint_3 = OpConstant %uint 3
     %uint_7 = OpConstant %uint 7
     %uint_8 = OpConstant %uint 8
    %float_1 = OpConstant %float 1
    %float_2 = OpConstant %float 2
    %float_3 = OpConstant %float 3

; Reference type declarations
         %ptr_v3float = OpTypePointer Function %v3float
          %ptr_uint_I = OpTypePointer Input %uint
    %arr_v4uint_uint2 = OpTypeArray %v4uint %uint_2
%ptr_arr_v4uint_uint2 = OpTypePointer Function %arr_v4uint_uint2
            %ptr_uint = OpTypePointer Function %uint
          %ptr_v4uint = OpTypePointer Function %v4uint

; Constant reference declarations
         %v3float_1 = OpConstantComposite %v3float %float_1 %float_1 %float_1
          %v4uint_0 = OpConstantComposite %v4uint %uint_0 %uint_0 %uint_0 %uint_0
%arr_v4uint_0_uint2 = OpConstantComposite %arr_v4uint_uint2 %v4uint_0 %v4uint_0

; Variable declarations
        %sid = OpVariable %ptr_uint_I Input

; Function declaration
  %fun_soriu = OpTypeFunction %void %v3float %v3float %ptr_v3float %ptr_v3float
      %soriu = OpFunction %void Inline|Const %fun_soriu
          %a = OpFunctionParameter %v3float
         %d0 = OpFunctionParameter %v3float
         %i0 = OpFunctionParameter %ptr_v3float
         %i1 = OpFunctionParameter %ptr_v3float

; Function definition begin
          %1 = OpLabel

; Initialize the accumulator array
        %acc = OpVariable %ptr_arr_v4uint_uint2 Function %arr_v4uint_0_uint2

; Calculate the clusterID
          %2 = OpLoad %uint %sid
        %cid = OpBitwiseAnd %uint %2 %uint_7

; Calculate d0_inv, d0_dot_inv, d0_nrm_dot and a_max
     %d0_inv = OpFDiv %v3float %v3float_1 %d0
          %3 = OpDot %float %d0 %v3float_1
 %d0_dot_inv = OpFDiv %float %float_1 %3
          %4 = OpCompositeConstruct %v3float %d0_dot_inv %d0_dot_inv %d0_dot_inv
 %d0_nrm_dot = OpFMul %v3float %d0 %4
          %5 = OpCompositeExtract %float %a 0
          %6 = OpCompositeExtract %float %a 1
          %7 = OpExtInst %float %glsl FMax %5 %6
          %8 = OpCompositeExtract %float %a 2
      %a_max = OpExtInst %float %glsl FMax %7 %8

; Calculate the intersection distances on all axis
          %9 = OpConvertUToF %float %cid
         %10 = OpExtInst %float %glsl Fma %9 %float_3 %float_1
         %11 = OpFSub %float %10 %a_max
         %12 = OpFMul %float %11 %d0_dot_inv
         %13 = OpCompositeConstruct %v3float %12 %12 %12
         %14 = OpExtInst %v3float %glsl Fma %d0 %13 %a
         %15 = OpExtInst %v3float %glsl Round %14
         %16 = OpFNegate %v3float %a
         %p0 = OpExtInst %v3float %glsl Fma %16 %d0_inv %15

         %17 = OpFAdd %v3float %13 %d0_nrm_dot
         %18 = OpExtInst %v3float %glsl Fma %d0 %17 %a
         %19 = OpExtInst %v3float %glsl Round %18
         %p1 = OpExtInst %v3float %glsl Fma %16 %d0_inv %19

         %20 = OpFAdd %v3float %17 %d0_nrm_dot
         %21 = OpExtInst %v3float %glsl Fma %d0 %20 %a
         %22 = OpExtInst %v3float %glsl Round %21
         %p2 = OpExtInst %v3float %glsl Fma %16 %d0_inv %22

; Find the maximum intersection distances
         %23 = OpCompositeExtract %float %p0 0
         %24 = OpCompositeExtract %float %p0 1
         %25 = OpExtInst %float %glsl FMax %23 %24
         %26 = OpCompositeExtract %float %p0 2
         %t0 = OpExtInst %float %glsl FMax %25 %26

         %27 = OpCompositeExtract %float %p1 0
         %28 = OpCompositeExtract %float %p1 1
         %29 = OpExtInst %float %glsl FMax %27 %28
         %30 = OpCompositeExtract %float %p1 2
         %t1 = OpExtInst %float %glsl FMax %29 %30

         %31 = OpCompositeExtract %float %p2 0
         %32 = OpCompositeExtract %float %p2 1
         %33 = OpExtInst %float %glsl FMax %31 %32
         %34 = OpCompositeExtract %float %p2 2
         %t2 = OpExtInst %float %glsl FMax %33 %34

; Round the intersection distances
         %35 = OpCompositeConstruct %v3float %t0 %t0 %t0
         %36 = OpExtInst %v3float %glsl Fma %d0 %35 %a
         %v0 = OpExtInst %v3float %glsl Floor %36

         %37 = OpCompositeConstruct %v3float %t1 %t1 %t1
         %38 = OpExtInst %v3float %glsl Fma %d0 %37 %a
         %v1 = OpExtInst %v3float %glsl Floor %38

         %39 = OpCompositeConstruct %v3float %t2 %t2 %t2
         %40 = OpExtInst %v3float %glsl Fma %d0 %39 %a
         %v2 = OpExtInst %v3float %glsl Floor %40

; Check which intersections are unique
         %41 = OpIAdd %uint %cid %uint_7
         %42 = OpBitwiseAnd %uint %41 %uint_7
         %43 = OpGroupNonUniformShuffle %v3float %uint_3 %v2 %42
         %44 = OpFOrdNotEqual %v3bool %43 %v0
         %u0 = OpAny %bool %44
         %45 = OpFOrdNotEqual %v3bool %v0 %v1
         %u1 = OpAny %bool %45
         %46 = OpFOrdNotEqual %v3bool %v1 %v2
         %u2 = OpAny %bool %46

; Calculate the insertion offset of intersections
         %47 = OpSelect %uint %u0 %uint_1 %uint_0
         %48 = OpSelect %uint %u1 %uint_1 %uint_0
         %49 = OpIAdd %uint %47 %48
         %50 = OpSelect %uint %u2 %uint_1 %uint_0
         %51 = OpIAdd %uint %49 %50
         %52 = OpGroupNonUniformIAdd %uint %uint_3 InclusiveScan %51
         %53 = OpLoad %uint %sid
         %54 = OpISub %uint %53 %uint_7
         %55 = OpGroupNonUniformShuffle %uint %uint_3 %52 %54
         %o0 = OpISub %uint %52 %55

; Insert the intersections if unique
         %56 = OpBitcast %uint %t0
         %57 = OpBitwiseAnd %uint %o0 %uint_1
         %58 = OpShiftRightLogical %uint %o0 %uint_1
         %59 = OpAccessChain %ptr_uint %acc %57 %58
         %60 = OpLoad %uint %59
         %61 = OpULessThan %bool %o0 %uint_8
         %62 = OpLogicalAnd %bool %u0 %61
         %63 = OpSelect %uint %62 %56 %60
               OpStore %59 %63
         %64 = OpSelect %uint %u0 %uint_1 %uint_0
         %o1 = OpIAdd %uint %o0 %64

         %65 = OpBitcast %uint %t1
         %66 = OpBitwiseAnd %uint %o1 %uint_1
         %67 = OpShiftRightLogical %uint %o1 %uint_1
         %68 = OpAccessChain %ptr_uint %acc %65 %66
         %69 = OpLoad %uint %68
         %70 = OpULessThan %bool %o1 %uint_8
         %71 = OpLogicalAnd %bool %u1 %70
         %72 = OpSelect %uint %71 %65 %69
               OpStore %68 %72
         %73 = OpSelect %uint %u1 %uint_1 %uint_0
         %o2 = OpIAdd %uint %o1 %73

         %74 = OpBitcast %uint %t2
         %75 = OpBitwiseAnd %uint %o2 %uint_1
         %76 = OpShiftRightLogical %uint %o2 %uint_1
         %77 = OpAccessChain %ptr_uint %acc %74 %75
         %78 = OpLoad %uint %77
         %79 = OpULessThan %bool %o2 %uint_8
         %80 = OpLogicalAnd %bool %u2 %79
         %81 = OpSelect %uint %80 %74 %78
               OpStore %77 %81

; Combine the results in the cluster
         %82 = OpAccessChain %ptr_v4uint %acc %uint_0
         %83 = OpLoad %v4uint %82
         %84 = OpGroupNonUniformBitwiseOr %v4uint %uint_3 ClusteredReduce %83 %uint_8
               OpStore %82 %84
         %85 = OpAccessChain %ptr_v4uint %acc %uint_1
         %86 = OpLoad %v4uint %85
         %87 = OpGroupNonUniformBitwiseOr %v4uint %uint_3 ClusteredReduce %86 %uint_8
               OpStore %85 %87

; Extract and round the outbound intersection
         %88 = OpShiftRightLogical %uint %cid %uint_1
         %89 = OpBitwiseAnd %uint %cid %uint_1
         %90 = OpAccessChain %ptr_uint %acc %88 %89
         %91 = OpLoad %uint %90
         %92 = OpBitcast %float %91
         %93 = OpCompositeConstruct %v3float %92 %92 %92
         %94 = OpExtInst %v3float %glsl Fma %d0 %93 %a
         %95 = OpExtInst %v3float %glsl Floor %94
               OpStore %i1 %95

; Share to get the inbound intersection
         %96 = OpGroupNonUniformShuffleUp %v3float %uint_3 %95 %uint_1
         %97 = OpIEqual %bool %cid %uint_0
         %98 = OpCompositeConstruct %v3bool %97 %97 %97
         %99 = OpSelect %v3float %98 %a %96
               OpStore %i0 %99

; Function definition end
               OpReturn
               OpFunctionEnd
