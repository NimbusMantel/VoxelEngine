; SPIR-V
; Version: 1.3
; Generator: Khronos SPIR-V Tools Assembler; 0
; Bound: 177
; Schema: 0
               OpCapability Shader
               OpCapability GroupNonUniform
               OpCapability GroupNonUniformArithmetic
               OpCapability GroupNonUniformShuffle
               OpCapability GroupNonUniformShuffleRelative
               OpCapability GroupNonUniformClustered
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint GLCompute %2 "main" %SubgroupLocalInvocationId
               OpExecutionMode %2 LocalSize 32 32 1
               OpDecorate %SubgroupLocalInvocationId RelaxedPrecision
               OpDecorate %SubgroupLocalInvocationId BuiltIn SubgroupLocalInvocationId
               OpDecorate %4 RelaxedPrecision
               OpDecorate %5 RelaxedPrecision
               OpDecorate %6 NoContraction
               OpDecorate %7 NoContraction
               OpDecorate %8 NoContraction
               OpDecorate %9 NoContraction
               OpDecorate %10 NoContraction
               OpDecorate %11 NoContraction
               OpDecorate %12 NoContraction
               OpDecorate %13 NoContraction
               OpDecorate %14 NoContraction
               OpDecorate %15 NoContraction
               OpDecorate %16 NoContraction
               OpDecorate %17 NoContraction
               OpDecorate %18 NoContraction
               OpDecorate %19 NoContraction
               OpDecorate %20 NoContraction
               OpDecorate %20 RelaxedPrecision
               OpDecorate %21 NoContraction
               OpDecorate %22 NoContraction
               OpDecorate %23 NoContraction
               OpDecorate %gl_WorkGroupSize BuiltIn WorkgroupSize
       %void = OpTypeVoid
         %26 = OpTypeFunction %void
       %uint = OpTypeInt 32 0
%_ptr_Function_uint = OpTypePointer Function %uint
%_ptr_Input_uint = OpTypePointer Input %uint
%SubgroupLocalInvocationId = OpVariable %_ptr_Input_uint Input
     %uint_7 = OpConstant %uint 7
      %float = OpTypeFloat 32
    %v3float = OpTypeVector %float 3
    %float_1 = OpConstant %float 1
    %float_2 = OpConstant %float 2
    %float_3 = OpConstant %float 3
         %36 = OpConstantComposite %v3float %float_1 %float_1 %float_1
     %uint_0 = OpConstant %uint 0
     %uint_1 = OpConstant %uint 1
     %uint_2 = OpConstant %uint 2
     %v3uint = OpTypeVector %uint 3
       %bool = OpTypeBool
     %uint_3 = OpConstant %uint 3
     %v3bool = OpTypeVector %bool 3
     %v4uint = OpTypeVector %uint 4
%_arr_v4uint_uint_2 = OpTypeArray %v4uint %uint_2
%_ptr_Function__arr_v4uint_uint_2 = OpTypePointer Function %_arr_v4uint_uint_2
%_ptr_Function_v4uint = OpTypePointer Function %v4uint
     %uint_8 = OpConstant %uint 8
    %uint_32 = OpConstant %uint 32
%gl_WorkGroupSize = OpConstantComposite %v3uint %uint_32 %uint_32 %uint_1
; INPUT vec3 x0
         %50 = OpUndef %v3float
; INPUT vec3 off
         %51 = OpUndef %v3float
; INPUT uint sca
         %52 = OpUndef %uint
          %2 = OpFunction %void None %26
         %53 = OpLabel
         %54 = OpVariable %_ptr_Function__arr_v4uint_uint_2 Function
; Calculate the clusterID
          %4 = OpLoad %uint %SubgroupLocalInvocationId
          %5 = OpBitwiseAnd %uint %4 %uint_7
; Calculate x0_inv, x0_dot_inv and off_max
          %6 = OpFDiv %v3float %36 %50
         %55 = OpDot %float %50 %36
          %7 = OpFDiv %float %float_1 %55
         %56 = OpExtInst %float %1 FMax %float_3 %float_2
         %57 = OpExtInst %float %1 FMax %56 %float_1
; Calculate the intersection distances on all axis
          %8 = OpFNegate %v3float %51
         %58 = OpConvertUToF %float %5
         %59 = OpExtInst %float %1 Fma %58 %float_3 %float_1
          %9 = OpFSub %float %59 %57
         %10 = OpFMul %float %9 %7
         %60 = OpCompositeConstruct %v3float %10 %10 %10
         %61 = OpExtInst %v3float %1 Fma %50 %60 %51
         %62 = OpExtInst %v3float %1 Round %61
         %63 = OpExtInst %v3float %1 Fma %8 %6 %62
         %11 = OpFNegate %v3float %51
         %64 = OpConvertUToF %float %5
         %65 = OpExtInst %float %1 Fma %64 %float_3 %float_2
         %12 = OpFSub %float %65 %57
         %13 = OpFMul %float %12 %7
         %66 = OpCompositeConstruct %v3float %13 %13 %13
         %67 = OpExtInst %v3float %1 Fma %50 %66 %51
         %68 = OpExtInst %v3float %1 Round %67
         %69 = OpExtInst %v3float %1 Fma %11 %6 %68
         %14 = OpFNegate %v3float %51
         %70 = OpConvertUToF %float %5
         %71 = OpExtInst %float %1 Fma %70 %float_3 %float_3
         %15 = OpFSub %float %71 %57
         %16 = OpFMul %float %15 %7
         %72 = OpCompositeConstruct %v3float %16 %16 %16
         %73 = OpExtInst %v3float %1 Fma %50 %72 %51
         %74 = OpExtInst %v3float %1 Round %73
         %75 = OpExtInst %v3float %1 Fma %14 %6 %74
; Find the maximum intersection distances
         %76 = OpCompositeExtract %float %63 0
         %77 = OpCompositeExtract %float %63 1
         %78 = OpExtInst %float %1 FMax %76 %77
         %79 = OpCompositeExtract %float %63 2
         %80 = OpExtInst %float %1 FMax %78 %79
         %81 = OpCompositeExtract %float %69 0
         %82 = OpCompositeExtract %float %69 1
         %83 = OpExtInst %float %1 FMax %81 %82
         %84 = OpCompositeExtract %float %69 2
         %85 = OpExtInst %float %1 FMax %83 %84
         %86 = OpCompositeExtract %float %75 0
         %87 = OpCompositeExtract %float %75 1
         %88 = OpExtInst %float %1 FMax %86 %87
         %89 = OpCompositeExtract %float %75 2
         %90 = OpExtInst %float %1 FMax %88 %89
; Round the intersection distances
         %91 = OpCompositeConstruct %v3float %80 %80 %80
         %92 = OpExtInst %v3float %1 Fma %50 %91 %51
         %93 = OpBitcast %v3uint %92
         %94 = OpCompositeConstruct %v3uint %52 %52 %52
         %95 = OpShiftRightLogical %v3uint %93 %94
         %96 = OpCompositeConstruct %v3uint %52 %52 %52
         %97 = OpShiftLeftLogical %v3uint %95 %96
         %98 = OpBitcast %v3float %97
         %99 = OpCompositeConstruct %v3float %85 %85 %85
        %100 = OpExtInst %v3float %1 Fma %50 %99 %51
        %101 = OpBitcast %v3uint %100
        %102 = OpCompositeConstruct %v3uint %52 %52 %52
        %103 = OpShiftRightLogical %v3uint %101 %102
        %104 = OpCompositeConstruct %v3uint %52 %52 %52
        %105 = OpShiftLeftLogical %v3uint %103 %104
        %106 = OpBitcast %v3float %105
        %107 = OpCompositeConstruct %v3float %90 %90 %90
        %108 = OpExtInst %v3float %1 Fma %50 %107 %51
        %109 = OpBitcast %v3uint %108
        %110 = OpCompositeConstruct %v3uint %52 %52 %52
        %111 = OpShiftRightLogical %v3uint %109 %110
        %112 = OpCompositeConstruct %v3uint %52 %52 %52
        %113 = OpShiftLeftLogical %v3uint %111 %112
        %114 = OpBitcast %v3float %113
; Check which intersections are unique
         %17 = OpIAdd %uint %5 %uint_7
        %115 = OpBitwiseAnd %uint %17 %uint_7
        %116 = OpGroupNonUniformShuffle %v3float %uint_3 %98 %115
        %117 = OpFOrdNotEqual %v3bool %116 %98
        %118 = OpAny %bool %117
        %119 = OpFOrdNotEqual %v3bool %98 %106
        %120 = OpAny %bool %119
        %121 = OpFOrdNotEqual %v3bool %106 %114
        %122 = OpAny %bool %121
; Calculate the insertion offset of intersections
        %123 = OpSelect %uint %118 %uint_1 %uint_0
        %124 = OpSelect %uint %120 %uint_1 %uint_0
         %18 = OpIAdd %uint %123 %124
        %125 = OpSelect %uint %122 %uint_1 %uint_0
         %19 = OpIAdd %uint %18 %125
        %126 = OpGroupNonUniformIAdd %uint %uint_3 InclusiveScan %19
         %20 = OpISub %uint %4 %uint_7
        %127 = OpGroupNonUniformShuffle %uint %uint_3 %126 %20
         %21 = OpISub %uint %126 %127
; Insert the first intersection if unique
        %128 = OpBitcast %uint %80
        %129 = OpBitwiseAnd %uint %21 %uint_1
        %130 = OpShiftRightLogical %uint %21 %uint_1
        %131 = OpAccessChain %_ptr_Function_uint %54 %129 %130
        %132 = OpLoad %uint %131
        %133 = OpULessThan %bool %21 %uint_7
        %134 = OpLogicalAnd %bool %118 %133
        %135 = OpSelect %uint %134 %128 %132
               OpStore %131 %135
        %136 = OpSelect %uint %118 %uint_1 %uint_0
         %22 = OpIAdd %uint %21 %136
; Insert the second intersection if unique
        %137 = OpBitcast %uint %85
        %138 = OpBitwiseAnd %uint %22 %uint_1
        %139 = OpShiftRightLogical %uint %22 %uint_1
        %140 = OpAccessChain %_ptr_Function_uint %54 %138 %139
        %141 = OpLoad %uint %140
        %142 = OpULessThan %bool %22 %uint_7
        %143 = OpLogicalAnd %bool %120 %142
        %144 = OpSelect %uint %143 %137 %141
               OpStore %140 %144
        %145 = OpSelect %uint %120 %uint_1 %uint_0
         %23 = OpIAdd %uint %22 %145
; Insert the third intersection if unique
        %146 = OpBitcast %uint %90
        %147 = OpBitwiseAnd %uint %23 %uint_1
        %148 = OpShiftRightLogical %uint %23 %uint_1
        %149 = OpAccessChain %_ptr_Function_uint %54 %147 %148
        %150 = OpLoad %uint %149
        %151 = OpULessThan %bool %23 %uint_7
        %152 = OpLogicalAnd %bool %122 %151
        %153 = OpSelect %uint %152 %146 %150
               OpStore %149 %153
; Combine the results in the cluster
        %154 = OpAccessChain %_ptr_Function_v4uint %54 %uint_0
        %155 = OpLoad %v4uint %154
        %156 = OpGroupNonUniformBitwiseOr %v4uint %uint_3 ClusteredReduce %155 %uint_8
               OpStore %154 %156
        %157 = OpAccessChain %_ptr_Function_v4uint %54 %uint_1
        %158 = OpLoad %v4uint %157
        %159 = OpGroupNonUniformBitwiseOr %v4uint %uint_3 ClusteredReduce %158 %uint_8
               OpStore %157 %159
; Extract and round the outbound intersection
        %160 = OpShiftRightLogical %uint %5 %uint_1
        %161 = OpBitwiseAnd %uint %5 %uint_1
        %162 = OpAccessChain %_ptr_Function_uint %54 %160 %161
        %163 = OpLoad %uint %162
        %164 = OpBitcast %float %163
        %165 = OpCompositeConstruct %v3float %164 %164 %164
        %166 = OpExtInst %v3float %1 Fma %50 %165 %51
        %167 = OpBitcast %v3uint %166
        %168 = OpCompositeConstruct %v3uint %52 %52 %52
        %169 = OpShiftRightLogical %v3uint %167 %168
        %170 = OpCompositeConstruct %v3uint %52 %52 %52
        %171 = OpShiftLeftLogical %v3uint %169 %170
; OUTPUT vec3 vxt
        %172 = OpBitcast %v3float %171
; Share to get the inbound intersection
        %173 = OpGroupNonUniformShuffleUp %v3float %uint_3 %172 %uint_1
        %174 = OpIEqual %bool %5 %uint_0
        %175 = OpCompositeConstruct %v3bool %174 %174 %174
; OUTPUT vec3 vxf
        %176 = OpSelect %v3float %175 %51 %173
               OpReturn
               OpFunctionEnd
